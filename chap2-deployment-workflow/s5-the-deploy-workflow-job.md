# The deploy workflow job
In this section, we address the deployment workflow job, a crucial part of our CI/CD pipeline designed for deploying our service. Triggered upon the successful completion of the build-and-push job, this job takes the reins to roll out the latest version of our service.

## Understanding Deployment in Context
Before we explore the deploy workflow, let's contextualize what deployment entails within the scope of this book. Deployment, while a broad topic with numerous facets, will be simplified here to focus on the essence of what it means to deploy a service.

At its core, a deployment process involves updating a service to a new version, typically by changing the service's running environment to utilize the latest application image. This is orchestrated through configuration files, which can be viewed as a blueprint detailing how the service should be deployed. These files dictate various parameters such as the service image to use, environment variables, secrets, and more.

### Deployment configuration file
For illustrative purposes, we will utilize a Kubernetes deployment configuration file. It's important to note that an understading of Kubernetes is not required for this discussion. Our objective is to illustrate how such a configuration file represents the deployment instructions:

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: workout-management-service
  labels:
    app: workout-management-service
spec:
    replicas: 3
    selector:
        matchLabels:
        app: workout-management-service
    template:
        metadata:
        labels:
            app: workout-management-service
        spec:
        containers:
        - name: workout-management-service
          image: ghcr.io/SamirMarin/workout-management-service:<tag>
          ports:
          - containerPort: 1323
```

This file outlines the deployment setup for our service, most importantly it defines the <image:tag> to use. The essence of our deploy workflow job, therefore, lies in updating this deployment configuration file to reference the latest Docker image tag. This update process signifies the deployment of our newest service version. By automating the update to point to the image tag generated by our recent build-and-push job, we achieve an effective and streamlined deployment.

We'll house this file within our repository, specifically in a deploy/ directory. For the sake of simplicity in our explanation, we'll bypass the actual deployment execution using this file. Instead, let's conceptualize that merely updating this file to reference the latest image tag equates to deploying our service. Imagine a Continuous Delivery (CD) tool in play, vigilantly tracking changes to this file on our repository's default branch. Upon detecting any modifications, this hypothetical CD tool would automatically roll out our service, thereby enacting the deployment based on our updated configuration.

lets place this file under the deploy/ directory in our repository:

```bash
mkdir -p deploy
touch deploy/workout-management-service-deployment.yaml
```

## Creating the deploy workflow job